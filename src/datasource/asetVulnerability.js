const EdgeDatasource = require('./edge');
const { aql } = require('arangojs');

class AsetVulnerabilityAPI extends EdgeDatasource {
  constructor() {
    super({
      timestamps: true,
      collectionType: 'edge'
    });
    this.collectionName = 'aset_vulnerability';
  }
  
  /**
   * Menghubungkan vulnerability dengan aset
   * @param {string} asetId - ID aset
   * @param {string} vulnerabilityId - ID vulnerability
   * @param {Object} metadata - Data tambahan tentang relasi (opsional)
   * @returns {Promise<Object>} - OperationResult
   */
  async assignVulnerabilityToAset(asetId, vulnerabilityId, metadata = {}) {
    try {
      // Pastikan ID dalam format yang benar
      const fromId = asetId.startsWith('entity/') ? asetId : `entity/${asetId}`;
      const toId = vulnerabilityId.startsWith('vulner/') ? vulnerabilityId : `vulner/${vulnerabilityId}`;
      
      // Tambahkan metadata standar
      const updatedMetadata = {
        ...metadata,
        status: metadata.status || 'detected',
        severity: metadata.severity || 'medium',
        detectedAt: metadata.detectedAt || new Date().toISOString(),
        dateAssigned: new Date().toISOString()
      };
      
      // Buat edge
      await this.createEdge(fromId, toId, updatedMetadata);
      
      // Kembalikan respons dengan success dan pesan
      return {
        success: true,
        message: `Berhasil mengaitkan vulnerability ${vulnerabilityId} ke aset ${asetId}`
      };
    } catch (error) {
      console.error(`Error assigning vulnerability ${vulnerabilityId} to asset ${asetId}:`, error);
      
      return {
        success: false,
        message: `Gagal mengaitkan vulnerability: ${error.message}`
      };
    }
  }
  
  /**
   * Menghapus kaitan vulnerability dari aset
   * @param {string} asetId - ID aset
   * @param {string} vulnerabilityId - ID vulnerability
   * @returns {Promise<Object>} - OperationResult
   */
  async removeVulnerabilityFromAset(asetId, vulnerabilityId) {
    if (!this.db) {
      await this.initialize();
    }
    
    try {
      // Pastikan ID dalam format yang benar
      const fromId = asetId.startsWith('entity/') ? asetId : `entity/${asetId}`;
      const toId = vulnerabilityId.startsWith('vulner/') ? vulnerabilityId : `vulner/${vulnerabilityId}`;
      
      const collection = await this.getCollection(this.collectionName);
      
      const cursor = await this.db.query(aql`
        FOR edge IN ${collection}
        FILTER edge._from == ${fromId} AND edge._to == ${toId}
        REMOVE edge IN ${collection}
        RETURN OLD
      `);
      
      const results = await cursor.all();
      const success = results.length > 0;
      
      return {
        success: success,
        message: success 
          ? `Berhasil menghapus kaitan vulnerability ${vulnerabilityId} dari aset ${asetId}` 
          : 'Relasi tidak ditemukan'
      };
    } catch (error) {
      return {
        success: false,
        message: `Gagal menghapus kaitan: ${error.message}`
      };
    }
  }
  
  /**
   * Mendapatkan semua vulnerability untuk aset tertentu
   * @param {string} asetId - ID aset
   * @returns {Promise<Array>} - Array vulnerability
   */
  async getVulnerabilityByAsetId(asetId) {
    if (!this.db) {
      await this.initialize();
    }
    
    try {
      // Pastikan ID dalam format yang benar
      const fromId = asetId.startsWith('entity/') ? asetId : `entity/${asetId}`;
      
      const collection = await this.getCollection(this.collectionName);
      
      const cursor = await this.db.query(aql`
        FOR edge IN ${collection}
        FILTER edge._from == ${fromId}
        LET vulner = DOCUMENT(edge._to)
        RETURN {
          _key: vulner._key,
          nama: vulner.nama,
          skor: vulner.skor,
          type: vulner.type,
          severity: vulner.severity,
          createdAt: edge.createdAt,
          updatedAt: edge.updatedAt,
        }
      `);
      
      return await cursor.all();
    } catch (error) {
      console.error(`Error fetching vulnerabilities for asset ${asetId}:`, error);
      throw error;
    }
  }
  
  /**
   * Mendapatkan semua aset yang terkait dengan vulnerability tertentu
   * @param {string} vulnerabilityId - ID vulnerability
   * @returns {Promise<Array>} - Array aset
   */
  async getAsetsByVulnerabilityId(vulnerabilityId) {
    if (!this.db) {
      await this.initialize();
    }
    
    try {
      // Pastikan ID dalam format yang benar
      const toId = vulnerabilityId.startsWith('vulner/') ? vulnerabilityId : `vulner/${vulnerabilityId}`;
      
      const collection = await this.getCollection(this.collectionName);
      
      const cursor = await this.db.query(aql`
        FOR edge IN ${collection}
        FILTER edge._to == ${toId}
        LET aset = DOCUMENT(edge._from)
        RETURN {
          _key: aset._key,
          nama: aset.nama,
          type: aset.type,
          createdAt: aset.createdAt,
          updatedAt: aset.updatedAt,
        }
      `);
      
      return await cursor.all();
    } catch (error) {
      console.error(`Error fetching assets for vulnerability ${vulnerabilityId}:`, error);
      throw error;
    }
  }
  
  /**
   * Update status vulnerability pada aset
   * @param {string} asetId - ID aset
   * @param {string} vulnerabilityId - ID vulnerability
   * @param {Object} updates - Data yang akan diupdate (status, severity, notes, dll)
   * @returns {Promise<Object>} - OperationResult
   */
  async updateVulnerabilityStatus(asetId, vulnerabilityId, updates) {
    if (!this.db) {
      await this.initialize();
    }
    
    try {
      // Pastikan ID dalam format yang benar
      const fromId = asetId.startsWith('entity/') ? asetId : `entity/${asetId}`;
      const toId = vulnerabilityId.startsWith('vulner/') ? vulnerabilityId : `vulner/${vulnerabilityId}`;
      
      const collection = await this.getCollection(this.collectionName);
      
      // Tambahkan timestamp
      const updatedData = {
        ...updates,
        updatedAt: new Date().toISOString()
      };
      
      const cursor = await this.db.query(aql`
        FOR edge IN ${collection}
        FILTER edge._from == ${fromId} AND edge._to == ${toId}
        UPDATE edge WITH ${updatedData} IN ${collection}
        RETURN NEW
      `);
      
      const results = await cursor.all();
      const success = results.length > 0;
      
      return {
        success: success,
        message: success 
          ? `Berhasil memperbarui status vulnerability ${vulnerabilityId} pada aset ${asetId}` 
          : 'Relasi tidak ditemukan'
      };
    } catch (error) {
      return {
        success: false,
        message: `Gagal memperbarui status: ${error.message}`
      };
    }
  }
  
  /**
   * Cek apakah vulnerability terkait dengan aset
   * @param {string} asetId - ID aset
   * @param {string} vulnerabilityId - ID vulnerability
   * @returns {Promise<Object>} - OperationResult dengan data isConnected
   */
  async checkVulnerabilityInAset(asetId, vulnerabilityId) {
    if (!this.db) {
      await this.initialize();
    }
    
    try {
      // Pastikan ID dalam format yang benar
      const fromId = asetId.startsWith('entity/') ? asetId : `entity/${asetId}`;
      const toId = vulnerabilityId.startsWith('vulner/') ? vulnerabilityId : `vulner/${vulnerabilityId}`;
      
      const collection = await this.getCollection(this.collectionName);
      
      const cursor = await this.db.query(aql`
        FOR edge IN ${collection}
        FILTER edge._from == ${fromId} AND edge._to == ${toId}
        LIMIT 1
        RETURN edge
      `);
      
      const results = await cursor.all();
      const isConnected = results.length > 0;
      
      return {
        success: true,
        message: isConnected 
          ? `Vulnerability ${vulnerabilityId} terkait dengan aset ${asetId}` 
          : `Vulnerability ${vulnerabilityId} tidak terkait dengan aset ${asetId}`,
        isConnected: isConnected,
        data: isConnected ? results[0] : null
      };
    } catch (error) {
      console.error(`Error checking if vulnerability ${vulnerabilityId} is in asset ${asetId}:`, error);
      return {
        success: false,
        message: `Gagal memeriksa kaitan: ${error.message}`,
        isConnected: false
      };
    }
  }
  
  /**
   * Mendapatkan statistik vulnerability untuk aset
   * @param {string} asetId - ID aset
   * @returns {Promise<Object>} - Statistik vulnerability
   */
  async getVulnerabilityStatsByAset(asetId) {
    if (!this.db) {
      await this.initialize();
    }
    
    try {
      // Pastikan ID dalam format yang benar
      const fromId = asetId.startsWith('entity/') ? asetId : `entity/${asetId}`;
      
      const collection = await this.getCollection(this.collectionName);
      
      const cursor = await this.db.query(aql`
        LET vulnerabilities = (
          FOR edge IN ${collection}
          FILTER edge._from == ${fromId}
          RETURN edge
        )
        
        RETURN {
          total: LENGTH(vulnerabilities),
          countBySeverity: {
            critical: LENGTH(vulnerabilities[* FILTER CURRENT.severity == "critical"]),
            high: LENGTH(vulnerabilities[* FILTER CURRENT.severity == "high"]),
            medium: LENGTH(vulnerabilities[* FILTER CURRENT.severity == "medium"]),
            low: LENGTH(vulnerabilities[* FILTER CURRENT.severity == "low"]),
            info: LENGTH(vulnerabilities[* FILTER CURRENT.severity == "info"])
          },
          countByStatus: {
            open: LENGTH(vulnerabilities[* FILTER CURRENT.status == "open" OR CURRENT.status == "detected"]),
            inProgress: LENGTH(vulnerabilities[* FILTER CURRENT.status == "in_progress"]),
            resolved: LENGTH(vulnerabilities[* FILTER CURRENT.status == "resolved"]),
            falsePositive: LENGTH(vulnerabilities[* FILTER CURRENT.status == "false_positive"]),
            accepted: LENGTH(vulnerabilities[* FILTER CURRENT.status == "accepted"])
          }
        }
      `);
      
      const results = await cursor.all();
      return results[0];
    } catch (error) {
      console.error(`Error getting vulnerability stats for asset ${asetId}:`, error);
      throw error;
    }
  }
}

module.exports = new AsetVulnerabilityAPI();